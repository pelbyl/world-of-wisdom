// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package db

import (
	"database/sql/driver"
	"fmt"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

type ChallengeStatus string

const (
	ChallengeStatusPending   ChallengeStatus = "pending"
	ChallengeStatusSolving   ChallengeStatus = "solving"
	ChallengeStatusCompleted ChallengeStatus = "completed"
	ChallengeStatusFailed    ChallengeStatus = "failed"
	ChallengeStatusExpired   ChallengeStatus = "expired"
)

func (e *ChallengeStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ChallengeStatus(s)
	case string:
		*e = ChallengeStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ChallengeStatus: %T", src)
	}
	return nil
}

type NullChallengeStatus struct {
	ChallengeStatus ChallengeStatus `json:"challenge_status"`
	Valid           bool            `json:"valid"` // Valid is true if ChallengeStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChallengeStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ChallengeStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ChallengeStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChallengeStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ChallengeStatus), nil
}

type ConnectionStatus string

const (
	ConnectionStatusConnected    ConnectionStatus = "connected"
	ConnectionStatusSolving      ConnectionStatus = "solving"
	ConnectionStatusDisconnected ConnectionStatus = "disconnected"
	ConnectionStatusFailed       ConnectionStatus = "failed"
)

func (e *ConnectionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ConnectionStatus(s)
	case string:
		*e = ConnectionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ConnectionStatus: %T", src)
	}
	return nil
}

type NullConnectionStatus struct {
	ConnectionStatus ConnectionStatus `json:"connection_status"`
	Valid            bool             `json:"valid"` // Valid is true if ConnectionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullConnectionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ConnectionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ConnectionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullConnectionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ConnectionStatus), nil
}

type PowAlgorithm string

const (
	PowAlgorithmSha256 PowAlgorithm = "sha256"
	PowAlgorithmArgon2 PowAlgorithm = "argon2"
)

func (e *PowAlgorithm) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PowAlgorithm(s)
	case string:
		*e = PowAlgorithm(s)
	default:
		return fmt.Errorf("unsupported scan type for PowAlgorithm: %T", src)
	}
	return nil
}

type NullPowAlgorithm struct {
	PowAlgorithm PowAlgorithm `json:"pow_algorithm"`
	Valid        bool         `json:"valid"` // Valid is true if PowAlgorithm is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPowAlgorithm) Scan(value interface{}) error {
	if value == nil {
		ns.PowAlgorithm, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PowAlgorithm.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPowAlgorithm) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PowAlgorithm), nil
}

type Block struct {
	ID           int32              `json:"id"`
	BlockIndex   int32              `json:"block_index"`
	ChallengeID  pgtype.UUID        `json:"challenge_id"`
	SolutionID   pgtype.UUID        `json:"solution_id"`
	Quote        pgtype.Text        `json:"quote"`
	PreviousHash pgtype.Text        `json:"previous_hash"`
	BlockHash    string             `json:"block_hash"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type Challenge struct {
	ID            pgtype.UUID        `json:"id"`
	Seed          string             `json:"seed"`
	Difficulty    int32              `json:"difficulty"`
	Algorithm     PowAlgorithm       `json:"algorithm"`
	ClientID      string             `json:"client_id"`
	Status        ChallengeStatus    `json:"status"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	SolvedAt      pgtype.Timestamptz `json:"solved_at"`
	ExpiresAt     pgtype.Timestamptz `json:"expires_at"`
	Argon2Time    pgtype.Int4        `json:"argon2_time"`
	Argon2Memory  pgtype.Int4        `json:"argon2_memory"`
	Argon2Threads pgtype.Int2        `json:"argon2_threads"`
	Argon2Keylen  pgtype.Int4        `json:"argon2_keylen"`
}

type ChallengeStat struct {
	Algorithm      PowAlgorithm    `json:"algorithm"`
	Difficulty     int32           `json:"difficulty"`
	Status         ChallengeStatus `json:"status"`
	Count          int64           `json:"count"`
	AvgSolveTimeMs float64         `json:"avg_solve_time_ms"`
}

type Connection struct {
	ID                  pgtype.UUID        `json:"id"`
	ClientID            string             `json:"client_id"`
	RemoteAddr          netip.Addr         `json:"remote_addr"`
	Status              ConnectionStatus   `json:"status"`
	Algorithm           PowAlgorithm       `json:"algorithm"`
	ConnectedAt         pgtype.Timestamptz `json:"connected_at"`
	DisconnectedAt      pgtype.Timestamptz `json:"disconnected_at"`
	ChallengesAttempted pgtype.Int4        `json:"challenges_attempted"`
	ChallengesCompleted pgtype.Int4        `json:"challenges_completed"`
	TotalSolveTimeMs    pgtype.Int8        `json:"total_solve_time_ms"`
}

type ConnectionStat struct {
	Algorithm              PowAlgorithm     `json:"algorithm"`
	Status                 ConnectionStatus `json:"status"`
	Count                  int64            `json:"count"`
	AvgChallengesCompleted float64          `json:"avg_challenges_completed"`
	AvgTotalSolveTimeMs    float64          `json:"avg_total_solve_time_ms"`
}

type Metric struct {
	Time           pgtype.Timestamptz `json:"time"`
	MetricName     string             `json:"metric_name"`
	MetricValue    float64            `json:"metric_value"`
	Labels         []byte             `json:"labels"`
	ServerInstance pgtype.Text        `json:"server_instance"`
}

type Solution struct {
	ID          pgtype.UUID        `json:"id"`
	ChallengeID pgtype.UUID        `json:"challenge_id"`
	Nonce       string             `json:"nonce"`
	Hash        string             `json:"hash"`
	Attempts    pgtype.Int4        `json:"attempts"`
	SolveTimeMs int64              `json:"solve_time_ms"`
	Verified    bool               `json:"verified"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}
