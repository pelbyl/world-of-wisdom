// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: solutions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSolution = `-- name: CreateSolution :one
INSERT INTO solutions (
    challenge_id, nonce, hash, attempts, solve_time_ms, verified
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, challenge_id, nonce, hash, attempts, solve_time_ms, verified, created_at
`

type CreateSolutionParams struct {
	ChallengeID pgtype.UUID `json:"challenge_id"`
	Nonce       string      `json:"nonce"`
	Hash        string      `json:"hash"`
	Attempts    pgtype.Int4 `json:"attempts"`
	SolveTimeMs int64       `json:"solve_time_ms"`
	Verified    bool        `json:"verified"`
}

func (q *Queries) CreateSolution(ctx context.Context, db DBTX, arg CreateSolutionParams) (Solution, error) {
	row := db.QueryRow(ctx, createSolution,
		arg.ChallengeID,
		arg.Nonce,
		arg.Hash,
		arg.Attempts,
		arg.SolveTimeMs,
		arg.Verified,
	)
	var i Solution
	err := row.Scan(
		&i.ID,
		&i.ChallengeID,
		&i.Nonce,
		&i.Hash,
		&i.Attempts,
		&i.SolveTimeMs,
		&i.Verified,
		&i.CreatedAt,
	)
	return i, err
}

const getRecentSolutions = `-- name: GetRecentSolutions :many
SELECT s.id, s.challenge_id, s.nonce, s.hash, s.attempts, s.solve_time_ms, s.verified, s.created_at, c.difficulty, c.algorithm 
FROM solutions s
JOIN challenges c ON s.challenge_id = c.id
WHERE s.created_at >= NOW() - INTERVAL '1 hour'
ORDER BY s.created_at DESC
LIMIT $1
`

type GetRecentSolutionsRow struct {
	ID          pgtype.UUID        `json:"id"`
	ChallengeID pgtype.UUID        `json:"challenge_id"`
	Nonce       string             `json:"nonce"`
	Hash        string             `json:"hash"`
	Attempts    pgtype.Int4        `json:"attempts"`
	SolveTimeMs int64              `json:"solve_time_ms"`
	Verified    bool               `json:"verified"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	Difficulty  int32              `json:"difficulty"`
	Algorithm   PowAlgorithm       `json:"algorithm"`
}

func (q *Queries) GetRecentSolutions(ctx context.Context, db DBTX, limit int32) ([]GetRecentSolutionsRow, error) {
	rows, err := db.Query(ctx, getRecentSolutions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentSolutionsRow{}
	for rows.Next() {
		var i GetRecentSolutionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChallengeID,
			&i.Nonce,
			&i.Hash,
			&i.Attempts,
			&i.SolveTimeMs,
			&i.Verified,
			&i.CreatedAt,
			&i.Difficulty,
			&i.Algorithm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSolution = `-- name: GetSolution :one
SELECT id, challenge_id, nonce, hash, attempts, solve_time_ms, verified, created_at FROM solutions WHERE id = $1
`

func (q *Queries) GetSolution(ctx context.Context, db DBTX, id pgtype.UUID) (Solution, error) {
	row := db.QueryRow(ctx, getSolution, id)
	var i Solution
	err := row.Scan(
		&i.ID,
		&i.ChallengeID,
		&i.Nonce,
		&i.Hash,
		&i.Attempts,
		&i.SolveTimeMs,
		&i.Verified,
		&i.CreatedAt,
	)
	return i, err
}

const getSolutionStats = `-- name: GetSolutionStats :one
SELECT 
    COUNT(*) as total_solutions,
    AVG(solve_time_ms) as avg_solve_time_ms,
    MIN(solve_time_ms) as min_solve_time_ms,
    MAX(solve_time_ms) as max_solve_time_ms,
    COUNT(CASE WHEN verified = true THEN 1 END) as verified_count
FROM solutions 
WHERE created_at >= NOW() - INTERVAL '24 hours'
`

type GetSolutionStatsRow struct {
	TotalSolutions int64       `json:"total_solutions"`
	AvgSolveTimeMs float64     `json:"avg_solve_time_ms"`
	MinSolveTimeMs interface{} `json:"min_solve_time_ms"`
	MaxSolveTimeMs interface{} `json:"max_solve_time_ms"`
	VerifiedCount  int64       `json:"verified_count"`
}

func (q *Queries) GetSolutionStats(ctx context.Context, db DBTX) (GetSolutionStatsRow, error) {
	row := db.QueryRow(ctx, getSolutionStats)
	var i GetSolutionStatsRow
	err := row.Scan(
		&i.TotalSolutions,
		&i.AvgSolveTimeMs,
		&i.MinSolveTimeMs,
		&i.MaxSolveTimeMs,
		&i.VerifiedCount,
	)
	return i, err
}

const getSolutionsByChallenge = `-- name: GetSolutionsByChallenge :many
SELECT id, challenge_id, nonce, hash, attempts, solve_time_ms, verified, created_at FROM solutions 
WHERE challenge_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetSolutionsByChallenge(ctx context.Context, db DBTX, challengeID pgtype.UUID) ([]Solution, error) {
	rows, err := db.Query(ctx, getSolutionsByChallenge, challengeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Solution{}
	for rows.Next() {
		var i Solution
		if err := rows.Scan(
			&i.ID,
			&i.ChallengeID,
			&i.Nonce,
			&i.Hash,
			&i.Attempts,
			&i.SolveTimeMs,
			&i.Verified,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const verifySolution = `-- name: VerifySolution :one
UPDATE solutions 
SET verified = $2
WHERE id = $1 
RETURNING id, challenge_id, nonce, hash, attempts, solve_time_ms, verified, created_at
`

type VerifySolutionParams struct {
	ID       pgtype.UUID `json:"id"`
	Verified bool        `json:"verified"`
}

func (q *Queries) VerifySolution(ctx context.Context, db DBTX, arg VerifySolutionParams) (Solution, error) {
	row := db.QueryRow(ctx, verifySolution, arg.ID, arg.Verified)
	var i Solution
	err := row.Scan(
		&i.ID,
		&i.ChallengeID,
		&i.Nonce,
		&i.Hash,
		&i.Attempts,
		&i.SolveTimeMs,
		&i.Verified,
		&i.CreatedAt,
	)
	return i, err
}
