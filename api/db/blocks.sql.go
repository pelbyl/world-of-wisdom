// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: blocks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBlock = `-- name: CreateBlock :one
INSERT INTO blocks (
    block_index, challenge_id, solution_id, quote, previous_hash, block_hash
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, block_index, challenge_id, solution_id, quote, previous_hash, block_hash, created_at
`

type CreateBlockParams struct {
	BlockIndex   int32       `json:"block_index"`
	ChallengeID  pgtype.UUID `json:"challenge_id"`
	SolutionID   pgtype.UUID `json:"solution_id"`
	Quote        pgtype.Text `json:"quote"`
	PreviousHash pgtype.Text `json:"previous_hash"`
	BlockHash    string      `json:"block_hash"`
}

func (q *Queries) CreateBlock(ctx context.Context, db DBTX, arg CreateBlockParams) (Block, error) {
	row := db.QueryRow(ctx, createBlock,
		arg.BlockIndex,
		arg.ChallengeID,
		arg.SolutionID,
		arg.Quote,
		arg.PreviousHash,
		arg.BlockHash,
	)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BlockIndex,
		&i.ChallengeID,
		&i.SolutionID,
		&i.Quote,
		&i.PreviousHash,
		&i.BlockHash,
		&i.CreatedAt,
	)
	return i, err
}

const getBlock = `-- name: GetBlock :one
SELECT id, block_index, challenge_id, solution_id, quote, previous_hash, block_hash, created_at FROM blocks WHERE id = $1
`

func (q *Queries) GetBlock(ctx context.Context, db DBTX, id int32) (Block, error) {
	row := db.QueryRow(ctx, getBlock, id)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BlockIndex,
		&i.ChallengeID,
		&i.SolutionID,
		&i.Quote,
		&i.PreviousHash,
		&i.BlockHash,
		&i.CreatedAt,
	)
	return i, err
}

const getBlockByIndex = `-- name: GetBlockByIndex :one
SELECT id, block_index, challenge_id, solution_id, quote, previous_hash, block_hash, created_at FROM blocks WHERE block_index = $1
`

func (q *Queries) GetBlockByIndex(ctx context.Context, db DBTX, blockIndex int32) (Block, error) {
	row := db.QueryRow(ctx, getBlockByIndex, blockIndex)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BlockIndex,
		&i.ChallengeID,
		&i.SolutionID,
		&i.Quote,
		&i.PreviousHash,
		&i.BlockHash,
		&i.CreatedAt,
	)
	return i, err
}

const getBlockchain = `-- name: GetBlockchain :many
SELECT b.id, b.block_index, b.challenge_id, b.solution_id, b.quote, b.previous_hash, b.block_hash, b.created_at, c.difficulty, c.algorithm, s.solve_time_ms 
FROM blocks b
LEFT JOIN challenges c ON b.challenge_id = c.id
LEFT JOIN solutions s ON b.solution_id = s.id
ORDER BY b.block_index ASC
`

type GetBlockchainRow struct {
	ID           int32              `json:"id"`
	BlockIndex   int32              `json:"block_index"`
	ChallengeID  pgtype.UUID        `json:"challenge_id"`
	SolutionID   pgtype.UUID        `json:"solution_id"`
	Quote        pgtype.Text        `json:"quote"`
	PreviousHash pgtype.Text        `json:"previous_hash"`
	BlockHash    string             `json:"block_hash"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Difficulty   pgtype.Int4        `json:"difficulty"`
	Algorithm    NullPowAlgorithm   `json:"algorithm"`
	SolveTimeMs  pgtype.Int8        `json:"solve_time_ms"`
}

func (q *Queries) GetBlockchain(ctx context.Context, db DBTX) ([]GetBlockchainRow, error) {
	rows, err := db.Query(ctx, getBlockchain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBlockchainRow{}
	for rows.Next() {
		var i GetBlockchainRow
		if err := rows.Scan(
			&i.ID,
			&i.BlockIndex,
			&i.ChallengeID,
			&i.SolutionID,
			&i.Quote,
			&i.PreviousHash,
			&i.BlockHash,
			&i.CreatedAt,
			&i.Difficulty,
			&i.Algorithm,
			&i.SolveTimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestBlock = `-- name: GetLatestBlock :one
SELECT id, block_index, challenge_id, solution_id, quote, previous_hash, block_hash, created_at FROM blocks 
ORDER BY block_index DESC 
LIMIT 1
`

func (q *Queries) GetLatestBlock(ctx context.Context, db DBTX) (Block, error) {
	row := db.QueryRow(ctx, getLatestBlock)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BlockIndex,
		&i.ChallengeID,
		&i.SolutionID,
		&i.Quote,
		&i.PreviousHash,
		&i.BlockHash,
		&i.CreatedAt,
	)
	return i, err
}

const getRecentBlocks = `-- name: GetRecentBlocks :many
SELECT b.id, b.block_index, b.challenge_id, b.solution_id, b.quote, b.previous_hash, b.block_hash, b.created_at, c.difficulty, c.algorithm, s.solve_time_ms 
FROM blocks b
LEFT JOIN challenges c ON b.challenge_id = c.id
LEFT JOIN solutions s ON b.solution_id = s.id
WHERE b.created_at >= NOW() - INTERVAL '1 hour'
ORDER BY b.block_index DESC
LIMIT $1
`

type GetRecentBlocksRow struct {
	ID           int32              `json:"id"`
	BlockIndex   int32              `json:"block_index"`
	ChallengeID  pgtype.UUID        `json:"challenge_id"`
	SolutionID   pgtype.UUID        `json:"solution_id"`
	Quote        pgtype.Text        `json:"quote"`
	PreviousHash pgtype.Text        `json:"previous_hash"`
	BlockHash    string             `json:"block_hash"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Difficulty   pgtype.Int4        `json:"difficulty"`
	Algorithm    NullPowAlgorithm   `json:"algorithm"`
	SolveTimeMs  pgtype.Int8        `json:"solve_time_ms"`
}

func (q *Queries) GetRecentBlocks(ctx context.Context, db DBTX, limit int32) ([]GetRecentBlocksRow, error) {
	rows, err := db.Query(ctx, getRecentBlocks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentBlocksRow{}
	for rows.Next() {
		var i GetRecentBlocksRow
		if err := rows.Scan(
			&i.ID,
			&i.BlockIndex,
			&i.ChallengeID,
			&i.SolutionID,
			&i.Quote,
			&i.PreviousHash,
			&i.BlockHash,
			&i.CreatedAt,
			&i.Difficulty,
			&i.Algorithm,
			&i.SolveTimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
