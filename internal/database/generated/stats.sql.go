// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: stats.sql

package db

import (
	"context"
)

const getChallengeDistribution = `-- name: GetChallengeDistribution :many
SELECT 
    difficulty,
    algorithm,
    COUNT(*) as count,
    AVG(CASE 
        WHEN status = 'completed' AND solved_at IS NOT NULL 
        THEN EXTRACT(EPOCH FROM (solved_at - created_at)) * 1000 
        ELSE NULL 
    END)::FLOAT as avg_solve_time_ms
FROM challenges
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY difficulty, algorithm
ORDER BY difficulty, algorithm
`

type GetChallengeDistributionRow struct {
	Difficulty     int32        `json:"difficulty"`
	Algorithm      PowAlgorithm `json:"algorithm"`
	Count          int64        `json:"count"`
	AvgSolveTimeMs float64      `json:"avg_solve_time_ms"`
}

// Get distribution of challenges by difficulty and algorithm
func (q *Queries) GetChallengeDistribution(ctx context.Context, db DBTX) ([]GetChallengeDistributionRow, error) {
	rows, err := db.Query(ctx, getChallengeDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChallengeDistributionRow{}
	for rows.Next() {
		var i GetChallengeDistributionRow
		if err := rows.Scan(
			&i.Difficulty,
			&i.Algorithm,
			&i.Count,
			&i.AvgSolveTimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChallengeStats = `-- name: GetChallengeStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'solving') as solving_count,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_count,
    COUNT(*) FILTER (WHERE status = 'expired') as expired_count,
    COUNT(*) as total_count,
    AVG(CASE 
        WHEN status = 'completed' AND solved_at IS NOT NULL 
        THEN EXTRACT(EPOCH FROM (solved_at - created_at)) * 1000 
        ELSE NULL 
    END)::FLOAT as avg_solve_time_ms,
    COUNT(*) FILTER (WHERE algorithm = 'sha256') as sha256_count,
    COUNT(*) FILTER (WHERE algorithm = 'argon2') as argon2_count
FROM challenges
WHERE created_at >= NOW() - INTERVAL '24 hours'
`

type GetChallengeStatsRow struct {
	PendingCount   int64   `json:"pending_count"`
	SolvingCount   int64   `json:"solving_count"`
	CompletedCount int64   `json:"completed_count"`
	FailedCount    int64   `json:"failed_count"`
	ExpiredCount   int64   `json:"expired_count"`
	TotalCount     int64   `json:"total_count"`
	AvgSolveTimeMs float64 `json:"avg_solve_time_ms"`
	Sha256Count    int64   `json:"sha256_count"`
	Argon2Count    int64   `json:"argon2_count"`
}

// Get aggregated challenge statistics for the API
func (q *Queries) GetChallengeStats(ctx context.Context, db DBTX) (GetChallengeStatsRow, error) {
	row := db.QueryRow(ctx, getChallengeStats)
	var i GetChallengeStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.SolvingCount,
		&i.CompletedCount,
		&i.FailedCount,
		&i.ExpiredCount,
		&i.TotalCount,
		&i.AvgSolveTimeMs,
		&i.Sha256Count,
		&i.Argon2Count,
	)
	return i, err
}

const getClientStats = `-- name: GetClientStats :many
SELECT 
    client_id,
    COUNT(*) as total_challenges,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_challenges,
    AVG(CASE 
        WHEN status = 'completed' AND solved_at IS NOT NULL 
        THEN EXTRACT(EPOCH FROM (solved_at - created_at)) * 1000 
        ELSE NULL 
    END)::FLOAT as avg_solve_time_ms,
    MAX(created_at) as last_challenge_time
FROM challenges
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY client_id
ORDER BY total_challenges DESC
LIMIT 100
`

type GetClientStatsRow struct {
	ClientID            string      `json:"client_id"`
	TotalChallenges     int64       `json:"total_challenges"`
	CompletedChallenges int64       `json:"completed_challenges"`
	AvgSolveTimeMs      float64     `json:"avg_solve_time_ms"`
	LastChallengeTime   interface{} `json:"last_challenge_time"`
}

// Get statistics per client ID
func (q *Queries) GetClientStats(ctx context.Context, db DBTX) ([]GetClientStatsRow, error) {
	rows, err := db.Query(ctx, getClientStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClientStatsRow{}
	for rows.Next() {
		var i GetClientStatsRow
		if err := rows.Scan(
			&i.ClientID,
			&i.TotalChallenges,
			&i.CompletedChallenges,
			&i.AvgSolveTimeMs,
			&i.LastChallengeTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHashRateHistory = `-- name: GetHashRateHistory :many
SELECT 
    time_bucket('5 minutes', s.created_at) as time_bucket,
    COUNT(*) as solution_count,
    SUM(s.attempts) as total_attempts,
    AVG(s.attempts)::FLOAT as avg_attempts_per_solution,
    AVG(c.difficulty)::FLOAT as avg_difficulty
FROM solutions s
JOIN challenges c ON s.challenge_id = c.id
WHERE s.created_at >= NOW() - INTERVAL '24 hours'
GROUP BY time_bucket
ORDER BY time_bucket DESC
`

type GetHashRateHistoryRow struct {
	TimeBucket             interface{} `json:"time_bucket"`
	SolutionCount          int64       `json:"solution_count"`
	TotalAttempts          int64       `json:"total_attempts"`
	AvgAttemptsPerSolution float64     `json:"avg_attempts_per_solution"`
	AvgDifficulty          float64     `json:"avg_difficulty"`
}

// Get historical hash rate data for charts (using solutions table)
func (q *Queries) GetHashRateHistory(ctx context.Context, db DBTX) ([]GetHashRateHistoryRow, error) {
	rows, err := db.Query(ctx, getHashRateHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHashRateHistoryRow{}
	for rows.Next() {
		var i GetHashRateHistoryRow
		if err := rows.Scan(
			&i.TimeBucket,
			&i.SolutionCount,
			&i.TotalAttempts,
			&i.AvgAttemptsPerSolution,
			&i.AvgDifficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
