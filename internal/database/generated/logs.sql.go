// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLogsByLevel = `-- name: CountLogsByLevel :many
SELECT level, COUNT(*) as count
FROM logs
WHERE timestamp >= NOW() - INTERVAL '24 hours'
GROUP BY level
`

type CountLogsByLevelRow struct {
	Level string `json:"level"`
	Count int64  `json:"count"`
}

func (q *Queries) CountLogsByLevel(ctx context.Context, db DBTX) ([]CountLogsByLevelRow, error) {
	rows, err := db.Query(ctx, countLogsByLevel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountLogsByLevelRow{}
	for rows.Next() {
		var i CountLogsByLevelRow
		if err := rows.Scan(&i.Level, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createLog = `-- name: CreateLog :one
INSERT INTO logs (
    timestamp, level, message, metadata
) VALUES (
    COALESCE($1, NOW()), $2, $3, $4
) RETURNING id, timestamp, level, message, metadata
`

type CreateLogParams struct {
	Column1  interface{} `json:"column_1"`
	Level    string      `json:"level"`
	Message  string      `json:"message"`
	Metadata []byte      `json:"metadata"`
}

func (q *Queries) CreateLog(ctx context.Context, db DBTX, arg CreateLogParams) (Log, error) {
	row := db.QueryRow(ctx, createLog,
		arg.Column1,
		arg.Level,
		arg.Message,
		arg.Metadata,
	)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.Level,
		&i.Message,
		&i.Metadata,
	)
	return i, err
}

const deleteOldLogs = `-- name: DeleteOldLogs :exec
DELETE FROM logs
WHERE timestamp < NOW() - INTERVAL '7 days'
`

func (q *Queries) DeleteOldLogs(ctx context.Context, db DBTX) error {
	_, err := db.Exec(ctx, deleteOldLogs)
	return err
}

const getLogsByLevel = `-- name: GetLogsByLevel :many
SELECT id, timestamp, level, message, metadata FROM logs
WHERE level = $1
ORDER BY timestamp DESC
LIMIT $2
`

type GetLogsByLevelParams struct {
	Level string `json:"level"`
	Limit int32  `json:"limit"`
}

func (q *Queries) GetLogsByLevel(ctx context.Context, db DBTX, arg GetLogsByLevelParams) ([]Log, error) {
	rows, err := db.Query(ctx, getLogsByLevel, arg.Level, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Level,
			&i.Message,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsInTimeRange = `-- name: GetLogsInTimeRange :many
SELECT id, timestamp, level, message, metadata FROM logs
WHERE timestamp >= $1 AND timestamp <= $2
ORDER BY timestamp DESC
`

type GetLogsInTimeRangeParams struct {
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
}

func (q *Queries) GetLogsInTimeRange(ctx context.Context, db DBTX, arg GetLogsInTimeRangeParams) ([]Log, error) {
	rows, err := db.Query(ctx, getLogsInTimeRange, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Level,
			&i.Message,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsPaginated = `-- name: GetLogsPaginated :many
SELECT id, timestamp, level, message, metadata FROM logs
WHERE ($1::timestamptz IS NULL OR timestamp < $1)
ORDER BY timestamp DESC
LIMIT $2
`

type GetLogsPaginatedParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Limit   int32              `json:"limit"`
}

func (q *Queries) GetLogsPaginated(ctx context.Context, db DBTX, arg GetLogsPaginatedParams) ([]Log, error) {
	rows, err := db.Query(ctx, getLogsPaginated, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Level,
			&i.Message,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLogs = `-- name: GetRecentLogs :many
SELECT id, timestamp, level, message, metadata FROM logs
ORDER BY timestamp DESC
LIMIT $1
`

func (q *Queries) GetRecentLogs(ctx context.Context, db DBTX, limit int32) ([]Log, error) {
	rows, err := db.Query(ctx, getRecentLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Level,
			&i.Message,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
