// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: metrics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDifficultyAdjustments = `-- name: CountDifficultyAdjustments :one
SELECT COUNT(*) as adjustment_count
FROM metrics 
WHERE metric_name = 'difficulty_adjustment'
  AND time >= NOW() - INTERVAL '1 hour'
`

func (q *Queries) CountDifficultyAdjustments(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, countDifficultyAdjustments)
	var adjustment_count int64
	err := row.Scan(&adjustment_count)
	return adjustment_count, err
}

const getAggregatedMetrics = `-- name: GetAggregatedMetrics :many
SELECT 
    time_bucket($1::INTERVAL, time) as bucket,
    metric_name,
    AVG(metric_value) as avg_value,
    MAX(metric_value) as max_value,
    MIN(metric_value) as min_value,
    COUNT(*) as sample_count
FROM metrics
WHERE time >= $2::TIMESTAMPTZ
  AND time <= $3::TIMESTAMPTZ
  AND ($4::VARCHAR IS NULL OR metric_name = $4)
GROUP BY bucket, metric_name
ORDER BY bucket DESC
LIMIT 500
`

type GetAggregatedMetricsParams struct {
	Interval   pgtype.Interval    `json:"interval"`
	StartTime  pgtype.Timestamptz `json:"start_time"`
	EndTime    pgtype.Timestamptz `json:"end_time"`
	MetricName string             `json:"metric_name"`
}

type GetAggregatedMetricsRow struct {
	Bucket      interface{} `json:"bucket"`
	MetricName  string      `json:"metric_name"`
	AvgValue    float64     `json:"avg_value"`
	MaxValue    interface{} `json:"max_value"`
	MinValue    interface{} `json:"min_value"`
	SampleCount int64       `json:"sample_count"`
}

// Get aggregated metrics with configurable time bucket
func (q *Queries) GetAggregatedMetrics(ctx context.Context, db DBTX, arg GetAggregatedMetricsParams) ([]GetAggregatedMetricsRow, error) {
	rows, err := db.Query(ctx, getAggregatedMetrics,
		arg.Interval,
		arg.StartTime,
		arg.EndTime,
		arg.MetricName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAggregatedMetricsRow{}
	for rows.Next() {
		var i GetAggregatedMetricsRow
		if err := rows.Scan(
			&i.Bucket,
			&i.MetricName,
			&i.AvgValue,
			&i.MaxValue,
			&i.MinValue,
			&i.SampleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricHistory = `-- name: GetMetricHistory :many
SELECT 
    time_bucket('1 minute', time) AS bucket,
    metric_name,
    AVG(metric_value) as avg_value,
    MIN(metric_value) as min_value,
    MAX(metric_value) as max_value,
    COUNT(*) as sample_count
FROM metrics 
WHERE metric_name = $1 
  AND time >= NOW() - INTERVAL '1 hour'
GROUP BY bucket, metric_name
ORDER BY bucket DESC
`

type GetMetricHistoryRow struct {
	Bucket      interface{} `json:"bucket"`
	MetricName  string      `json:"metric_name"`
	AvgValue    float64     `json:"avg_value"`
	MinValue    interface{} `json:"min_value"`
	MaxValue    interface{} `json:"max_value"`
	SampleCount int64       `json:"sample_count"`
}

func (q *Queries) GetMetricHistory(ctx context.Context, db DBTX, metricName string) ([]GetMetricHistoryRow, error) {
	rows, err := db.Query(ctx, getMetricHistory, metricName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMetricHistoryRow{}
	for rows.Next() {
		var i GetMetricHistoryRow
		if err := rows.Scan(
			&i.Bucket,
			&i.MetricName,
			&i.AvgValue,
			&i.MinValue,
			&i.MaxValue,
			&i.SampleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsByName = `-- name: GetMetricsByName :many
SELECT time, metric_name, metric_value, labels, server_instance FROM metrics 
WHERE metric_name = $1 
  AND time >= NOW() - INTERVAL '1 hour'
ORDER BY time DESC
LIMIT $2
`

type GetMetricsByNameParams struct {
	MetricName string `json:"metric_name"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) GetMetricsByName(ctx context.Context, db DBTX, arg GetMetricsByNameParams) ([]Metric, error) {
	rows, err := db.Query(ctx, getMetricsByName, arg.MetricName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Metric{}
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.Time,
			&i.MetricName,
			&i.MetricValue,
			&i.Labels,
			&i.ServerInstance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsByTimeRange = `-- name: GetMetricsByTimeRange :many
SELECT 
    time,
    metric_name,
    metric_value,
    labels
FROM metrics
WHERE time >= $1::TIMESTAMPTZ
  AND time <= $2::TIMESTAMPTZ
  AND ($3::VARCHAR IS NULL OR metric_name = $3)
ORDER BY time DESC
LIMIT 1000
`

type GetMetricsByTimeRangeParams struct {
	StartTime  pgtype.Timestamptz `json:"start_time"`
	EndTime    pgtype.Timestamptz `json:"end_time"`
	MetricName string             `json:"metric_name"`
}

type GetMetricsByTimeRangeRow struct {
	Time        pgtype.Timestamptz `json:"time"`
	MetricName  string             `json:"metric_name"`
	MetricValue float64            `json:"metric_value"`
	Labels      []byte             `json:"labels"`
}

// Get metrics within a specific time range with optional metric name filter
func (q *Queries) GetMetricsByTimeRange(ctx context.Context, db DBTX, arg GetMetricsByTimeRangeParams) ([]GetMetricsByTimeRangeRow, error) {
	rows, err := db.Query(ctx, getMetricsByTimeRange, arg.StartTime, arg.EndTime, arg.MetricName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMetricsByTimeRangeRow{}
	for rows.Next() {
		var i GetMetricsByTimeRangeRow
		if err := rows.Scan(
			&i.Time,
			&i.MetricName,
			&i.MetricValue,
			&i.Labels,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsFromContinuousAggregate = `-- name: GetMetricsFromContinuousAggregate :many
SELECT 
    time_bucket('5 minutes', time) as time,
    metric_name,
    AVG(metric_value) as avg_value,
    MAX(metric_value) as max_value,
    MIN(metric_value) as min_value,
    COUNT(*) as sample_count,
    labels
FROM metrics
WHERE time >= $1::TIMESTAMPTZ
  AND time <= $2::TIMESTAMPTZ
  AND ($3::VARCHAR IS NULL OR metric_name = $3)
GROUP BY time_bucket('5 minutes', time), metric_name, labels
ORDER BY time DESC
LIMIT 500
`

type GetMetricsFromContinuousAggregateParams struct {
	StartTime  pgtype.Timestamptz `json:"start_time"`
	EndTime    pgtype.Timestamptz `json:"end_time"`
	MetricName string             `json:"metric_name"`
}

type GetMetricsFromContinuousAggregateRow struct {
	Time        interface{} `json:"time"`
	MetricName  string      `json:"metric_name"`
	AvgValue    float64     `json:"avg_value"`
	MaxValue    interface{} `json:"max_value"`
	MinValue    interface{} `json:"min_value"`
	SampleCount int64       `json:"sample_count"`
	Labels      []byte      `json:"labels"`
}

// Get metrics aggregated by time bucket (simplified for clean architecture)
func (q *Queries) GetMetricsFromContinuousAggregate(ctx context.Context, db DBTX, arg GetMetricsFromContinuousAggregateParams) ([]GetMetricsFromContinuousAggregateRow, error) {
	rows, err := db.Query(ctx, getMetricsFromContinuousAggregate, arg.StartTime, arg.EndTime, arg.MetricName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMetricsFromContinuousAggregateRow{}
	for rows.Next() {
		var i GetMetricsFromContinuousAggregateRow
		if err := rows.Scan(
			&i.Time,
			&i.MetricName,
			&i.AvgValue,
			&i.MaxValue,
			&i.MinValue,
			&i.SampleCount,
			&i.Labels,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentMetrics = `-- name: GetRecentMetrics :many
SELECT DISTINCT ON (metric_name) 
    metric_name, metric_value, labels, time
FROM metrics 
WHERE time >= NOW() - INTERVAL '1 hour'
ORDER BY metric_name, time DESC
`

type GetRecentMetricsRow struct {
	MetricName  string             `json:"metric_name"`
	MetricValue float64            `json:"metric_value"`
	Labels      []byte             `json:"labels"`
	Time        pgtype.Timestamptz `json:"time"`
}

func (q *Queries) GetRecentMetrics(ctx context.Context, db DBTX) ([]GetRecentMetricsRow, error) {
	rows, err := db.Query(ctx, getRecentMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentMetricsRow{}
	for rows.Next() {
		var i GetRecentMetricsRow
		if err := rows.Scan(
			&i.MetricName,
			&i.MetricValue,
			&i.Labels,
			&i.Time,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemMetrics = `-- name: GetSystemMetrics :many
SELECT 
    metric_name,
    metric_value,
    labels,
    time
FROM metrics 
WHERE metric_name IN ('current_difficulty', 'active_connections', 'total_challenges', 'hash_rate')
  AND time >= NOW() - INTERVAL '5 minutes'
ORDER BY metric_name, time DESC
`

type GetSystemMetricsRow struct {
	MetricName  string             `json:"metric_name"`
	MetricValue float64            `json:"metric_value"`
	Labels      []byte             `json:"labels"`
	Time        pgtype.Timestamptz `json:"time"`
}

func (q *Queries) GetSystemMetrics(ctx context.Context, db DBTX) ([]GetSystemMetricsRow, error) {
	rows, err := db.Query(ctx, getSystemMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSystemMetricsRow{}
	for rows.Next() {
		var i GetSystemMetricsRow
		if err := rows.Scan(
			&i.MetricName,
			&i.MetricValue,
			&i.Labels,
			&i.Time,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordMetric = `-- name: RecordMetric :exec
INSERT INTO metrics (metric_name, metric_value, labels, server_instance)
VALUES ($1, $2, $3, $4)
`

type RecordMetricParams struct {
	MetricName     string      `json:"metric_name"`
	MetricValue    float64     `json:"metric_value"`
	Labels         []byte      `json:"labels"`
	ServerInstance pgtype.Text `json:"server_instance"`
}

func (q *Queries) RecordMetric(ctx context.Context, db DBTX, arg RecordMetricParams) error {
	_, err := db.Exec(ctx, recordMetric,
		arg.MetricName,
		arg.MetricValue,
		arg.Labels,
		arg.ServerInstance,
	)
	return err
}
