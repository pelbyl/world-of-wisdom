// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: client_behavior.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const calculateAndUpdateClientDifficulty = `-- name: CalculateAndUpdateClientDifficulty :one
UPDATE client_behaviors
SET 
    difficulty = calculate_adaptive_difficulty(
        failure_rate,
        avg_solve_time_ms,
        reconnect_rate,
        connection_count,
        reputation_score,
        difficulty
    ),
    updated_at = CURRENT_TIMESTAMP
WHERE ip_address = $1
RETURNING difficulty
`

func (q *Queries) CalculateAndUpdateClientDifficulty(ctx context.Context, db DBTX, ipAddress netip.Addr) (pgtype.Int4, error) {
	row := db.QueryRow(ctx, calculateAndUpdateClientDifficulty, ipAddress)
	var difficulty pgtype.Int4
	err := row.Scan(&difficulty)
	return difficulty, err
}

const createClientBehavior = `-- name: CreateClientBehavior :one
INSERT INTO client_behaviors (
    ip_address,
    connection_count,
    difficulty,
    last_connection
) VALUES (
    $1, 1, 2, CURRENT_TIMESTAMP
) RETURNING id, ip_address, connection_count, failure_rate, avg_solve_time_ms, last_connection, reconnect_rate, difficulty, total_challenges, successful_challenges, failed_challenges, total_solve_time_ms, suspicious_activity_score, reputation_score, last_reputation_update, created_at, updated_at
`

func (q *Queries) CreateClientBehavior(ctx context.Context, db DBTX, ipAddress netip.Addr) (ClientBehavior, error) {
	row := db.QueryRow(ctx, createClientBehavior, ipAddress)
	var i ClientBehavior
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.ConnectionCount,
		&i.FailureRate,
		&i.AvgSolveTimeMs,
		&i.LastConnection,
		&i.ReconnectRate,
		&i.Difficulty,
		&i.TotalChallenges,
		&i.SuccessfulChallenges,
		&i.FailedChallenges,
		&i.TotalSolveTimeMs,
		&i.SuspiciousActivityScore,
		&i.ReputationScore,
		&i.LastReputationUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createConnectionTimestamp = `-- name: CreateConnectionTimestamp :one
INSERT INTO connection_timestamps (
    client_behavior_id,
    connected_at
) VALUES (
    (SELECT id FROM client_behaviors WHERE ip_address = $1),
    CURRENT_TIMESTAMP
) RETURNING id, client_behavior_id, connected_at, disconnected_at, challenge_completed
`

func (q *Queries) CreateConnectionTimestamp(ctx context.Context, db DBTX, ipAddress netip.Addr) (ConnectionTimestamp, error) {
	row := db.QueryRow(ctx, createConnectionTimestamp, ipAddress)
	var i ConnectionTimestamp
	err := row.Scan(
		&i.ID,
		&i.ClientBehaviorID,
		&i.ConnectedAt,
		&i.DisconnectedAt,
		&i.ChallengeCompleted,
	)
	return i, err
}

const getActiveClients = `-- name: GetActiveClients :many
SELECT 
    cb.id, cb.ip_address, cb.connection_count, cb.failure_rate, cb.avg_solve_time_ms, cb.last_connection, cb.reconnect_rate, cb.difficulty, cb.total_challenges, cb.successful_challenges, cb.failed_challenges, cb.total_solve_time_ms, cb.suspicious_activity_score, cb.reputation_score, cb.last_reputation_update, cb.created_at, cb.updated_at,
    COUNT(c.id) FILTER (WHERE c.status = 'connected') as active_connections
FROM client_behaviors cb
LEFT JOIN connections c ON c.remote_addr = cb.ip_address AND c.status = 'connected'
WHERE cb.last_connection > NOW() - INTERVAL '1 hour'
GROUP BY cb.id
ORDER BY cb.difficulty DESC, cb.connection_count DESC
LIMIT $1
`

type GetActiveClientsRow struct {
	ID                      pgtype.UUID        `json:"id"`
	IpAddress               netip.Addr         `json:"ip_address"`
	ConnectionCount         pgtype.Int4        `json:"connection_count"`
	FailureRate             pgtype.Float8      `json:"failure_rate"`
	AvgSolveTimeMs          pgtype.Int8        `json:"avg_solve_time_ms"`
	LastConnection          pgtype.Timestamptz `json:"last_connection"`
	ReconnectRate           pgtype.Float8      `json:"reconnect_rate"`
	Difficulty              pgtype.Int4        `json:"difficulty"`
	TotalChallenges         pgtype.Int4        `json:"total_challenges"`
	SuccessfulChallenges    pgtype.Int4        `json:"successful_challenges"`
	FailedChallenges        pgtype.Int4        `json:"failed_challenges"`
	TotalSolveTimeMs        pgtype.Int8        `json:"total_solve_time_ms"`
	SuspiciousActivityScore pgtype.Float8      `json:"suspicious_activity_score"`
	ReputationScore         pgtype.Float8      `json:"reputation_score"`
	LastReputationUpdate    pgtype.Timestamptz `json:"last_reputation_update"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	ActiveConnections       int64              `json:"active_connections"`
}

func (q *Queries) GetActiveClients(ctx context.Context, db DBTX, limit int32) ([]GetActiveClientsRow, error) {
	rows, err := db.Query(ctx, getActiveClients, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveClientsRow{}
	for rows.Next() {
		var i GetActiveClientsRow
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.ConnectionCount,
			&i.FailureRate,
			&i.AvgSolveTimeMs,
			&i.LastConnection,
			&i.ReconnectRate,
			&i.Difficulty,
			&i.TotalChallenges,
			&i.SuccessfulChallenges,
			&i.FailedChallenges,
			&i.TotalSolveTimeMs,
			&i.SuspiciousActivityScore,
			&i.ReputationScore,
			&i.LastReputationUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ActiveConnections,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientBehaviorByIP = `-- name: GetClientBehaviorByIP :one
SELECT id, ip_address, connection_count, failure_rate, avg_solve_time_ms, last_connection, reconnect_rate, difficulty, total_challenges, successful_challenges, failed_challenges, total_solve_time_ms, suspicious_activity_score, reputation_score, last_reputation_update, created_at, updated_at FROM client_behaviors
WHERE ip_address = $1
`

func (q *Queries) GetClientBehaviorByIP(ctx context.Context, db DBTX, ipAddress netip.Addr) (ClientBehavior, error) {
	row := db.QueryRow(ctx, getClientBehaviorByIP, ipAddress)
	var i ClientBehavior
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.ConnectionCount,
		&i.FailureRate,
		&i.AvgSolveTimeMs,
		&i.LastConnection,
		&i.ReconnectRate,
		&i.Difficulty,
		&i.TotalChallenges,
		&i.SuccessfulChallenges,
		&i.FailedChallenges,
		&i.TotalSolveTimeMs,
		&i.SuspiciousActivityScore,
		&i.ReputationScore,
		&i.LastReputationUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientBehaviorStats = `-- name: GetClientBehaviorStats :many
SELECT 
    cb.id, cb.ip_address, cb.connection_count, cb.failure_rate, cb.avg_solve_time_ms, cb.last_connection, cb.reconnect_rate, cb.difficulty, cb.total_challenges, cb.successful_challenges, cb.failed_challenges, cb.total_solve_time_ms, cb.suspicious_activity_score, cb.reputation_score, cb.last_reputation_update, cb.created_at, cb.updated_at,
    COUNT(ch.id) as recent_challenges,
    AVG(s.solve_time_ms) FILTER (WHERE s.verified = true) as recent_avg_solve_time
FROM client_behaviors cb
LEFT JOIN challenges ch ON ch.client_id IN (
    SELECT client_id FROM connections WHERE remote_addr = cb.ip_address
) AND ch.created_at > NOW() - INTERVAL '10 minutes'
LEFT JOIN solutions s ON s.challenge_id = ch.id
GROUP BY cb.id
ORDER BY cb.suspicious_activity_score DESC
LIMIT $1
`

type GetClientBehaviorStatsRow struct {
	ID                      pgtype.UUID        `json:"id"`
	IpAddress               netip.Addr         `json:"ip_address"`
	ConnectionCount         pgtype.Int4        `json:"connection_count"`
	FailureRate             pgtype.Float8      `json:"failure_rate"`
	AvgSolveTimeMs          pgtype.Int8        `json:"avg_solve_time_ms"`
	LastConnection          pgtype.Timestamptz `json:"last_connection"`
	ReconnectRate           pgtype.Float8      `json:"reconnect_rate"`
	Difficulty              pgtype.Int4        `json:"difficulty"`
	TotalChallenges         pgtype.Int4        `json:"total_challenges"`
	SuccessfulChallenges    pgtype.Int4        `json:"successful_challenges"`
	FailedChallenges        pgtype.Int4        `json:"failed_challenges"`
	TotalSolveTimeMs        pgtype.Int8        `json:"total_solve_time_ms"`
	SuspiciousActivityScore pgtype.Float8      `json:"suspicious_activity_score"`
	ReputationScore         pgtype.Float8      `json:"reputation_score"`
	LastReputationUpdate    pgtype.Timestamptz `json:"last_reputation_update"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	RecentChallenges        int64              `json:"recent_challenges"`
	RecentAvgSolveTime      float64            `json:"recent_avg_solve_time"`
}

func (q *Queries) GetClientBehaviorStats(ctx context.Context, db DBTX, limit int32) ([]GetClientBehaviorStatsRow, error) {
	rows, err := db.Query(ctx, getClientBehaviorStats, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClientBehaviorStatsRow{}
	for rows.Next() {
		var i GetClientBehaviorStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.ConnectionCount,
			&i.FailureRate,
			&i.AvgSolveTimeMs,
			&i.LastConnection,
			&i.ReconnectRate,
			&i.Difficulty,
			&i.TotalChallenges,
			&i.SuccessfulChallenges,
			&i.FailedChallenges,
			&i.TotalSolveTimeMs,
			&i.SuspiciousActivityScore,
			&i.ReputationScore,
			&i.LastReputationUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecentChallenges,
			&i.RecentAvgSolveTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopAggressiveClients = `-- name: GetTopAggressiveClients :many
SELECT 
    ip_address,
    difficulty,
    connection_count,
    failure_rate,
    avg_solve_time_ms,
    reconnect_rate,
    reputation_score,
    suspicious_activity_score,
    last_connection,
    successful_challenges,
    failed_challenges,
    total_challenges
FROM client_behaviors
WHERE suspicious_activity_score > 50
   OR reputation_score < 20
   OR difficulty >= 5
ORDER BY suspicious_activity_score DESC, reputation_score ASC
LIMIT $1
`

type GetTopAggressiveClientsRow struct {
	IpAddress               netip.Addr         `json:"ip_address"`
	Difficulty              pgtype.Int4        `json:"difficulty"`
	ConnectionCount         pgtype.Int4        `json:"connection_count"`
	FailureRate             pgtype.Float8      `json:"failure_rate"`
	AvgSolveTimeMs          pgtype.Int8        `json:"avg_solve_time_ms"`
	ReconnectRate           pgtype.Float8      `json:"reconnect_rate"`
	ReputationScore         pgtype.Float8      `json:"reputation_score"`
	SuspiciousActivityScore pgtype.Float8      `json:"suspicious_activity_score"`
	LastConnection          pgtype.Timestamptz `json:"last_connection"`
	SuccessfulChallenges    pgtype.Int4        `json:"successful_challenges"`
	FailedChallenges        pgtype.Int4        `json:"failed_challenges"`
	TotalChallenges         pgtype.Int4        `json:"total_challenges"`
}

func (q *Queries) GetTopAggressiveClients(ctx context.Context, db DBTX, limit int32) ([]GetTopAggressiveClientsRow, error) {
	rows, err := db.Query(ctx, getTopAggressiveClients, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopAggressiveClientsRow{}
	for rows.Next() {
		var i GetTopAggressiveClientsRow
		if err := rows.Scan(
			&i.IpAddress,
			&i.Difficulty,
			&i.ConnectionCount,
			&i.FailureRate,
			&i.AvgSolveTimeMs,
			&i.ReconnectRate,
			&i.ReputationScore,
			&i.SuspiciousActivityScore,
			&i.LastConnection,
			&i.SuccessfulChallenges,
			&i.FailedChallenges,
			&i.TotalChallenges,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClientBehavior = `-- name: UpdateClientBehavior :one
UPDATE client_behaviors
SET 
    connection_count = connection_count + 1,
    last_connection = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE ip_address = $1
RETURNING id, ip_address, connection_count, failure_rate, avg_solve_time_ms, last_connection, reconnect_rate, difficulty, total_challenges, successful_challenges, failed_challenges, total_solve_time_ms, suspicious_activity_score, reputation_score, last_reputation_update, created_at, updated_at
`

func (q *Queries) UpdateClientBehavior(ctx context.Context, db DBTX, ipAddress netip.Addr) (ClientBehavior, error) {
	row := db.QueryRow(ctx, updateClientBehavior, ipAddress)
	var i ClientBehavior
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.ConnectionCount,
		&i.FailureRate,
		&i.AvgSolveTimeMs,
		&i.LastConnection,
		&i.ReconnectRate,
		&i.Difficulty,
		&i.TotalChallenges,
		&i.SuccessfulChallenges,
		&i.FailedChallenges,
		&i.TotalSolveTimeMs,
		&i.SuspiciousActivityScore,
		&i.ReputationScore,
		&i.LastReputationUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateClientChallengeStats = `-- name: UpdateClientChallengeStats :exec
UPDATE client_behaviors
SET 
    total_challenges = total_challenges + 1,
    successful_challenges = CASE WHEN $1::boolean THEN successful_challenges + 1 ELSE successful_challenges END,
    failed_challenges = CASE WHEN NOT $1::boolean THEN failed_challenges + 1 ELSE failed_challenges END,
    total_solve_time_ms = total_solve_time_ms + $2::bigint,
    avg_solve_time_ms = (total_solve_time_ms + $2::bigint) / NULLIF(successful_challenges + CASE WHEN $1::boolean THEN 1 ELSE 0 END, 0),
    failure_rate = failed_challenges::FLOAT / NULLIF(total_challenges + 1, 0),
    updated_at = CURRENT_TIMESTAMP
WHERE ip_address = $3
`

type UpdateClientChallengeStatsParams struct {
	IsSuccessful bool       `json:"is_successful"`
	SolveTimeMs  int64      `json:"solve_time_ms"`
	IpAddress    netip.Addr `json:"ip_address"`
}

func (q *Queries) UpdateClientChallengeStats(ctx context.Context, db DBTX, arg UpdateClientChallengeStatsParams) error {
	_, err := db.Exec(ctx, updateClientChallengeStats, arg.IsSuccessful, arg.SolveTimeMs, arg.IpAddress)
	return err
}

const updateClientDifficulty = `-- name: UpdateClientDifficulty :exec
UPDATE client_behaviors
SET 
    difficulty = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE ip_address = $1
`

type UpdateClientDifficultyParams struct {
	IpAddress  netip.Addr  `json:"ip_address"`
	Difficulty pgtype.Int4 `json:"difficulty"`
}

func (q *Queries) UpdateClientDifficulty(ctx context.Context, db DBTX, arg UpdateClientDifficultyParams) error {
	_, err := db.Exec(ctx, updateClientDifficulty, arg.IpAddress, arg.Difficulty)
	return err
}

const updateClientReconnectRate = `-- name: UpdateClientReconnectRate :exec
UPDATE client_behaviors
SET 
    reconnect_rate = calculate_reconnect_rate(id),
    updated_at = CURRENT_TIMESTAMP
WHERE ip_address = $1
`

func (q *Queries) UpdateClientReconnectRate(ctx context.Context, db DBTX, ipAddress netip.Addr) error {
	_, err := db.Exec(ctx, updateClientReconnectRate, ipAddress)
	return err
}

const updateClientReputation = `-- name: UpdateClientReputation :exec
SELECT update_reputation_score(
    (SELECT id FROM client_behaviors WHERE ip_address = $1),
    $2::boolean
)
`

type UpdateClientReputationParams struct {
	IpAddress        netip.Addr `json:"ip_address"`
	ChallengeSuccess bool       `json:"challenge_success"`
}

func (q *Queries) UpdateClientReputation(ctx context.Context, db DBTX, arg UpdateClientReputationParams) error {
	_, err := db.Exec(ctx, updateClientReputation, arg.IpAddress, arg.ChallengeSuccess)
	return err
}

const updateConnectionTimestamp = `-- name: UpdateConnectionTimestamp :exec
UPDATE connection_timestamps
SET 
    disconnected_at = CURRENT_TIMESTAMP,
    challenge_completed = $1::boolean
WHERE id = $2
`

type UpdateConnectionTimestampParams struct {
	ChallengeCompleted bool        `json:"challenge_completed"`
	ID                 pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateConnectionTimestamp(ctx context.Context, db DBTX, arg UpdateConnectionTimestampParams) error {
	_, err := db.Exec(ctx, updateConnectionTimestamp, arg.ChallengeCompleted, arg.ID)
	return err
}

const updateSuspiciousActivityScore = `-- name: UpdateSuspiciousActivityScore :exec
UPDATE client_behaviors
SET 
    suspicious_activity_score = CASE
        WHEN failure_rate > 0.8 THEN 90
        WHEN failure_rate > 0.6 AND reconnect_rate > 0.5 THEN 80
        WHEN avg_solve_time_ms < 500 AND avg_solve_time_ms > 0 THEN 85
        WHEN connection_count > 50 AND reputation_score < 30 THEN 75
        WHEN reconnect_rate > 0.7 THEN 70
        ELSE GREATEST(0, suspicious_activity_score - 5) -- Decay over time
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE ip_address = $1
`

func (q *Queries) UpdateSuspiciousActivityScore(ctx context.Context, db DBTX, ipAddress netip.Addr) error {
	_, err := db.Exec(ctx, updateSuspiciousActivityScore, ipAddress)
	return err
}
